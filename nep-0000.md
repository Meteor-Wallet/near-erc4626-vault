---
NEP: 0
Title: Vault NEP
Authors: Meteor Wallet
Status: New
DiscussionsTo: https://github.com/nearprotocol/neps/pull/0000
Type: Contract Standard
Requires: 141
Version: 1.0.0
Created: 2025-08-08
LastUpdated: 2025-08-08
---

## Summary

This NEP proposes a standardized interface for implementing vault contracts on the NEAR Protocol, drawing inspiration from the ERC-4626 standard widely used on Ethereum. A vault contract allows users to deposit an underlying fungible token (FT) into the vault, in exchange for which the vault issues shares that represent proportional ownership of the vault’s assets.

The underlying asset could be any NEP-141 compliant fungible token, or any NEP-245 compliant multi token, such as a stablecoin or yield-bearing token. When deposited, the vault mints new shares to the depositor based on the current exchange rate between the vault’s total assets and total shares in circulation. Conversely, when a user redeems shares, the vault burns those shares and returns the equivalent amount of the underlying asset to the user.

The issued shares themselves are also NEP-141 compliant fungible tokens, enabling them to be freely transferred between accounts or traded on decentralized exchanges (DEXs). This compatibility allows vault shares to be integrated into broader DeFi ecosystems, enabling use cases such as collateral in lending protocols, liquidity provision, or composable yield strategies.

By standardizing the vault interface, this NEP aims to improve interoperability, reduce integration costs, and encourage consistent, secure practices for vault implementation across the NEAR ecosystem.

## Motivation

Vault contracts are a fundamental building block in modern DeFi, enabling users to pool assets for yield generation, liquidity provision, or other strategies while receiving tokenized shares that represent their proportional ownership. However, without a standardized interface, each vault implementation on NEAR may expose different method names, return formats, and accounting mechanisms, creating unnecessary friction for developers, integrators, and auditors.

A consistent vault standard, inspired by ERC-4626, would provide multiple benefits:

-   Interoperability – Wallets, DEXs, lending protocols, and other DeFi applications can integrate with any compliant vault without custom logic for each implementation.

-   Reduced Integration Costs – Developers and projects save time and resources by building once against the standard interface rather than creating one-off integrations.

-   Ecosystem Growth – Standardized vaults make it easier for new projects to leverage existing liquidity and composability, accelerating adoption across the NEAR DeFi ecosystem.

By introducing this NEP, we aim to align vault design on NEAR with proven best practices from other blockchain ecosystems while optimizing for the unique features and requirements of NEP-141 fungible tokens.

## Specification

### Contract Interface

The contract should implement the VaultCore trait.

```rust
pub enum Asset {
    FungibleToken {
        contract_id: AccountId,
    },
    MultiToken {
        contract_id: AccountId,
        token_id: String,
    },
}

/// Specification for a fungible token vault that issues NEP-141 compliant shares.
///
/// A FungibleTokenVault accepts deposits of an underlying NEP-141 compliant asset
/// and issues NEP-141 compliant "shares" in return. These shares can be transferred
/// and traded like any other NEP-141 token.
///
/// This trait extends:
/// - [`FungibleTokenCore`] to provide NEP-141 functionality for shares.
pub trait VaultCore:
    FungibleTokenCore
{
    // ----------------------------
    // Asset Information
    // ----------------------------

    /// Returns the [`AccountId`] of the underlying asset token contract.
    ///
    /// The asset **must** be NEP-141 compliant.
    /// Implementations should store this as an immutable configuration value.
    fn asset(&self) -> AccountId;

    /// Returns the total amount of underlying assets represented by all shares in existence.
    ///
    /// **Important:**
    /// - Represents the vault's *total managed value*, not just assets held in the contract.
    /// - If assets are staked, lent, swapped, or deployed elsewhere, this should return
    ///   an **estimated total equivalent value**.
    /// - Must be denominated in the same units as [`Self::asset`].
    fn total_assets(&self) -> U128;

    // ----------------------------
    // Conversion Helpers
    // ----------------------------

    /// Converts an amount of underlying assets to the equivalent number of shares.
    ///
    /// This is a **purely view-only estimation** that:
    /// - Does not update state.
    /// - Ignores user-specific constraints such as deposit limits or fees.
    ///
    /// See also: [`Self::preview_deposit`] for a version that accounts for limits and fees.
    fn convert_to_shares(&self, assets: U128) -> U128;

    /// Converts an amount of shares to the equivalent amount of underlying assets.
    ///
    /// This is a **purely view-only estimation** that:
    /// - Does not update state.
    /// - Ignores withdrawal restrictions, fees, or penalties.
    ///
    /// See also: [`Self::preview_redeem`] for a version that accounts for real-world constraints.
    fn convert_to_assets(&self, shares: U128) -> U128;

    // ----------------------------
    // Deposit / Redemption Limits
    // ----------------------------

    /// Returns the maximum amount of underlying assets that `receiver_id` can deposit.
    ///
    /// This may depend on:
    /// - Vault capacity.
    /// - User-specific limits.
    /// - Current on-chain conditions.
    ///
    /// Implementations should return `U128::MAX` to signal "unlimited" deposits.
    fn max_deposit(&self, receiver_id: AccountId) -> U128;

    /// Simulates depositing exactly `assets` into the vault and returns the number of shares
    /// that would be minted to the receiver.
    ///
    /// Differs from [`Self::convert_to_shares`] by accounting for:
    /// - Per-user deposit limits.
    /// - Protocol-specific deposit fees.
    fn preview_deposit(&self, assets: U128) -> U128;

    /// Returns the maximum number of shares that `receiver_id` can mint.
    ///
    /// This may depend on:
    /// - Vault capacity.
    /// - User-specific limits.
    /// - Current on-chain conditions.
    ///
    /// Implementations should return `U128::MAX` to signal "unlimited" minting.
    fn max_mint(&self, receiver_id: AccountId) -> U128;

    /// Simulates minting exactly `shares` and returns the amount of underlying assets
    /// that would be required.
    ///
    /// Differs from [`Self::convert_to_assets`] by accounting for:
    /// - Per-user minting limits.
    /// - Protocol-specific minting fees.
    ///
    /// Useful for frontends to estimate the cost of minting shares.
    fn preview_mint(&self, shares: U128) -> U128;

    /// Returns the maximum number of shares that `owner_id` can redeem.
    ///
    /// This may depend on:
    /// - The owner's current share balance.
    /// - Vault withdrawal restrictions.
    /// - Lock-up periods or cooldowns.
    ///
    /// Implementations should return `0` if redemptions are currently disabled for the owner.
    fn max_redeem(&self, owner_id: AccountId) -> U128;

    /// Returns the maximum amount of assets that `owner_id` can withdraw.
    ///
    /// This may depend on:
    /// - The owner's share balance.
    /// - Current vault liquidity.
    /// - Withdrawal limits or cooldowns.
    fn max_withdraw(&self, owner_id: AccountId) -> U128;

    // ----------------------------
    // Redemption Operations
    // ----------------------------

    /// Redeems `shares` from the caller in exchange for the equivalent amount of underlying assets.
    ///
    /// - If `receiver_id` is `None`, defaults to sending assets to the caller.
    /// - Burns the caller's shares.
    /// - Returns the exact amount of assets redeemed.
    ///
    /// # Panics / Fails
    /// - If the caller's share balance is insufficient.
    /// - If withdrawal limits prevent the redemption.
    ///
    /// See also: [`Self::preview_redeem`].
    fn redeem(&mut self, shares: U128, receiver_id: Option<AccountId>) -> PromiseOrValue<U128>;

    /// Simulates redeeming `shares` into assets without executing the redemption.
    ///
    /// Differs from [`Self::convert_to_assets`] by factoring in:
    /// - The caller's current share balance.
    /// - Vault withdrawal limits.
    /// - Applicable fees or penalties.
    ///
    /// Useful for frontends to estimate redemption outcomes.
    fn preview_redeem(&self, shares: U128) -> U128;

    /// Withdraws exactly `assets` worth of underlying tokens from the vault.
    ///
    /// - If `receiver_id` is `None`, defaults to sending assets to the caller.
    /// - Burns the required number of shares to fulfill the withdrawal.
    ///
    /// # Panics / Fails
    /// - If the caller's share balance cannot cover the withdrawal.
    /// - If withdrawal limits or fees prevent the withdrawal.
    ///
    /// See also: [`Self::preview_withdraw`].
    fn withdraw(&mut self, assets: U128, receiver_id: Option<AccountId>) -> PromiseOrValue<U128>;

    /// Simulates withdrawing exactly `assets` worth of tokens without executing.
    ///
    /// Differs from [`Self::convert_to_shares`] by factoring in:
    /// - The caller's current share balance.
    /// - Vault withdrawal limits.
    /// - Applicable fees or penalties.
    ///
    /// Useful for frontends to preview required shares for a given withdrawal.
    fn preview_withdraw(&self, assets: U128) -> U128;
}
```

Additionally, the contract should implement the `ft_on_transfer` or `mt_on_transfer` method according to NEP-141 spec or NEP-245 spec
in order to receive the underlying asset.

### Events

```rust
/// Event emitted when a deposit is received by the vault.
///
/// This follows the proposed NEP vault standard, referencing the ERC-4626 pattern.
/// Upon receiving assets, the vault mints and issues shares to the `owner_id`.
pub struct VaultDeposit {
    /// The account that sends the deposit (payer of the assets).
    pub sender_id: AccountId,

    /// The account that receives the minted shares.
    pub owner_id: AccountId,

    /// Amount of underlying assets deposited into the vault.
    pub assets: U128,

    /// Amount of shares minted and issued to `owner_id`.
    pub shares: U128,

    /// Optional memo provided by the sender for off-chain use.
    pub memo: Option<String>,
}

/// Event emitted when shares are redeemed from the vault.
///
/// Upon redemption, the vault burns the shares from `owner_id`
/// and transfers the equivalent assets to `receiver_id`.
pub struct VaultWithdraw {
    /// The account that owns the shares being redeemed (burned).
    pub owner_id: AccountId,

    /// The account receiving the underlying assets.
    pub receiver_id: AccountId,

    /// Amount of shares redeemed (burned from the vault).
    pub shares: U128,

    /// Amount of underlying assets withdrawn from the vault.
    pub assets: U128,

    /// Optional memo provided by the redeemer for off-chain use.
    pub memo: Option<String>,
}

```

## Reference Implementation

[This technical section is required for Protocol proposals but optional for other categories. A draft implementation should demonstrate a minimal implementation that assists in understanding or implementing this proposal. Explain the design in sufficient detail that:

-   Its interaction with other features is clear.
-   Where possible, include a Minimum Viable Interface subsection expressing the required behavior and types in a target programming language. (ie. traits and structs for rust, interfaces and classes for javascript, function signatures and structs for c, etc.)
-   It is reasonably clear how the feature would be implemented.
-   Corner cases are dissected by example.
-   For protocol changes: A link to a draft PR on nearcore that shows how it can be integrated in the current code. It should at least solve the key technical challenges.

The section should return to the examples given in the previous section, and explain more fully how the detailed proposal makes those examples work.]

## Security Implications

[Explicitly outline any security concerns in relation to the NEP, and potential ways to resolve or mitigate them. At the very least, well-known relevant threats must be covered, e.g. person-in-the-middle, double-spend, XSS, CSRF, etc.]

## Alternatives

[Explain any alternative designs that were considered and the rationale for not choosing them. Why your design is superior?]

## Future possibilities

[Describe any natural extensions and evolutions to the NEP proposal, and how they would impact the project. Use this section as a tool to help fully consider all possible interactions with the project in your proposal. This is also a good place to "dump ideas"; if they are out of scope for the NEP but otherwise related. Note that having something written down in the future-possibilities section is not a reason to accept the current or a future NEP. Such notes should be in the section on motivation or rationale in this or subsequent NEPs. The section merely provides additional information.]

## Consequences

[This section describes the consequences, after applying the decision. All consequences should be summarized here, not just the "positive" ones. Record any concerns raised throughout the NEP discussion.]

### Positive

-   p1

### Neutral

-   n1

### Negative

-   n1

### Backwards Compatibility

[All NEPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. Author must explain a proposes to deal with these incompatibilities. Submissions without a sufficient backwards compatibility treatise may be rejected outright.]

## Unresolved Issues (Optional)

[Explain any issues that warrant further discussion. Considerations

-   What parts of the design do you expect to resolve through the NEP process before this gets merged?
-   What parts of the design do you expect to resolve through the implementation of this feature before stabilization?
-   What related issues do you consider out of scope for this NEP that could be addressed in the future independently of the solution that comes out of this NEP?]

## Changelog

[The changelog section provides historical context for how the NEP developed over time. Initial NEP submission should start with version 1.0.0, and all subsequent NEP extensions must follow [Semantic Versioning](https://semver.org/). Every version should have the benefits and concerns raised during the review. The author does not need to fill out this section for the initial draft. Instead, the assigned reviewers (Subject Matter Experts) should create the first version during the first technical review. After the final public call, the author should then finalize the last version of the decision context.]

### 1.0.0 - Initial Version

> Placeholder for the context about when and who approved this NEP version.

#### Benefits

> List of benefits filled by the Subject Matter Experts while reviewing this version:

-   Benefit 1
-   Benefit 2

#### Concerns

> Template for Subject Matter Experts review for this version:
> Status: New | Ongoing | Resolved

|   # | Concern | Resolution | Status |
| --: | :------ | :--------- | -----: |
|   1 |         |            |        |
|   2 |         |            |        |

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
