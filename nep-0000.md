---
NEP: 0
Title: Vault NEP
Authors: Meteor Wallet
Status: New
DiscussionsTo: https://github.com/nearprotocol/neps/pull/0000
Type: Contract Standard
Requires: 141
Version: 1.0.0
Created: 2025-08-08
LastUpdated: 2025-08-08
---

## Summary

This NEP proposes a standardized interface for implementing vault contracts on the NEAR Protocol, drawing inspiration from the ERC-4626 standard widely used on Ethereum. A vault contract allows users to deposit an underlying fungible token (FT) into the vault, in exchange for which the vault issues shares that represent proportional ownership of the vault’s assets.

The underlying asset could be any NEP-141 compliant fungible token, such as a stablecoin or yield-bearing token. When deposited, the vault mints new shares to the depositor based on the current exchange rate between the vault’s total assets and total shares in circulation. Conversely, when a user redeems shares, the vault burns those shares and returns the equivalent amount of the underlying asset to the user.

The issued shares themselves are also NEP-141 compliant fungible tokens, enabling them to be freely transferred between accounts or traded on decentralized exchanges (DEXs). This compatibility allows vault shares to be integrated into broader DeFi ecosystems, enabling use cases such as collateral in lending protocols, liquidity provision, or composable yield strategies.

By standardizing the vault interface, this NEP aims to improve interoperability, reduce integration costs, and encourage consistent, secure practices for vault implementation across the NEAR ecosystem.

## Motivation

Vault contracts are a fundamental building block in modern DeFi, enabling users to pool assets for yield generation, liquidity provision, or other strategies while receiving tokenized shares that represent their proportional ownership. However, without a standardized interface, each vault implementation on NEAR may expose different method names, return formats, and accounting mechanisms, creating unnecessary friction for developers, integrators, and auditors.

A consistent vault standard, inspired by ERC-4626, would provide multiple benefits:

-   Interoperability – Wallets, DEXs, lending protocols, and other DeFi applications can integrate with any compliant vault without custom logic for each implementation.

-   Reduced Integration Costs – Developers and projects save time and resources by building once against the standard interface rather than creating one-off integrations.

-   Ecosystem Growth – Standardized vaults make it easier for new projects to leverage existing liquidity and composability, accelerating adoption across the NEAR DeFi ecosystem.

By introducing this NEP, we aim to align vault design on NEAR with proven best practices from other blockchain ecosystems while optimizing for the unique features and requirements of NEP-141 fungible tokens.

## Specification

### Contract Interface

```rust
/// Specification for a fungible token vault that issues NEP-141 compliant shares.
///
/// A FungibleTokenVault accepts deposits of an underlying NEP-141 compliant asset
/// and issues NEP-141 compliant "shares" in return. These shares can be transferred
/// and traded like any other NEP-141 token.
///
/// This trait extends:
/// - [`FungibleTokenCore`] to provide NEP-141 functionality for shares.
/// - [`FungibleTokenReceiver`] to accept deposits of the underlying asset.
pub trait FungibleTokenVaultCore:
    FungibleTokenCore +
    FungibleTokenReceiver
{
    /// Returns the `AccountId` of the underlying asset token contract.
    ///
    /// The underlying asset must be NEP-141 compliant.
    fn asset(&self) -> AccountId;

    /// Returns the total amount of underlying assets represented by all shares in existence.
    ///
    /// Even if assets are staked, swapped, or moved elsewhere, this should return
    /// an **estimated** total equivalent value, not just the assets currently stored.
    fn total_assets(&self) -> U128;

    // ----------------------------
    // Conversion helper functions
    // ----------------------------

    /// Converts an amount of underlying assets to the equivalent number of shares.
    ///
    /// This is a view-only function for estimation purposes.
    fn convert_to_shares(&self, assets: U128) -> U128;

    /// Converts an amount of shares to the equivalent amount of underlying assets.
    ///
    /// This is a view-only function for estimation purposes.
    fn convert_to_assets(&self, shares: U128) -> U128;

    // ----------------------------
    // Deposit / redemption limits
    // ----------------------------

    /// Returns the maximum amount of underlying assets that `receiver_id` can deposit.
    fn max_deposit(&self, receiver_id: AccountId) -> U128;

    /// Returns the maximum number of shares that `owner_id` can redeem.
    fn max_redeem(&self, owner_id: AccountId) -> U128;

    // ----------------------------
    // Redemption operations
    // ----------------------------

    /// Redeems a given number of shares for the equivalent amount of underlying assets.
    ///
    /// Optionally sends the redeemed assets to `receiver_id`; if `None`, defaults to the caller.
    ///
    /// Returns the amount of assets redeemed.
    fn redeem(&mut self, shares: U128, receiver_id: Option<AccountId>) -> PromiseOrValue<U128>;

    /// Previews the result of redeeming a given number of shares.
    ///
    /// Unlike [`convert_to_assets`], this takes into account additional factors
    /// such as the caller's current share balance, withdrawal limits, and fees.
    fn preview_redeem(&self, shares: U128) -> U128;
}
```

### Events

```rust
/// Event emitted when a deposit is received by the vault.
///
/// This follows the proposed NEP vault standard, referencing the ERC-4626 pattern.
/// Upon receiving assets, the vault mints and issues shares to the `owner_id`.
pub struct VaultDeposit {
    /// The account that sends the deposit (payer of the assets).
    pub sender_id: AccountId,

    /// The account that receives the minted shares.
    pub owner_id: AccountId,

    /// Amount of underlying assets deposited into the vault.
    pub assets: U128,

    /// Amount of shares minted and issued to `owner_id`.
    pub shares: U128,

    /// Optional memo provided by the sender for off-chain use.
    pub memo: Option<String>,
}

/// Event emitted when shares are redeemed from the vault.
///
/// Upon redemption, the vault burns the shares from `owner_id`
/// and transfers the equivalent assets to `receiver_id`.
pub struct VaultWithdraw {
    /// The account that owns the shares being redeemed (burned).
    pub owner_id: AccountId,

    /// The account receiving the underlying assets.
    pub receiver_id: AccountId,

    /// Amount of shares redeemed (burned from the vault).
    pub shares: U128,

    /// Amount of underlying assets withdrawn from the vault.
    pub assets: U128,

    /// Optional memo provided by the redeemer for off-chain use.
    pub memo: Option<String>,
}

```

## Reference Implementation

[This technical section is required for Protocol proposals but optional for other categories. A draft implementation should demonstrate a minimal implementation that assists in understanding or implementing this proposal. Explain the design in sufficient detail that:

-   Its interaction with other features is clear.
-   Where possible, include a Minimum Viable Interface subsection expressing the required behavior and types in a target programming language. (ie. traits and structs for rust, interfaces and classes for javascript, function signatures and structs for c, etc.)
-   It is reasonably clear how the feature would be implemented.
-   Corner cases are dissected by example.
-   For protocol changes: A link to a draft PR on nearcore that shows how it can be integrated in the current code. It should at least solve the key technical challenges.

The section should return to the examples given in the previous section, and explain more fully how the detailed proposal makes those examples work.]

## Security Implications

[Explicitly outline any security concerns in relation to the NEP, and potential ways to resolve or mitigate them. At the very least, well-known relevant threats must be covered, e.g. person-in-the-middle, double-spend, XSS, CSRF, etc.]

## Alternatives

[Explain any alternative designs that were considered and the rationale for not choosing them. Why your design is superior?]

## Future possibilities

[Describe any natural extensions and evolutions to the NEP proposal, and how they would impact the project. Use this section as a tool to help fully consider all possible interactions with the project in your proposal. This is also a good place to "dump ideas"; if they are out of scope for the NEP but otherwise related. Note that having something written down in the future-possibilities section is not a reason to accept the current or a future NEP. Such notes should be in the section on motivation or rationale in this or subsequent NEPs. The section merely provides additional information.]

## Consequences

[This section describes the consequences, after applying the decision. All consequences should be summarized here, not just the "positive" ones. Record any concerns raised throughout the NEP discussion.]

### Positive

-   p1

### Neutral

-   n1

### Negative

-   n1

### Backwards Compatibility

[All NEPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. Author must explain a proposes to deal with these incompatibilities. Submissions without a sufficient backwards compatibility treatise may be rejected outright.]

## Unresolved Issues (Optional)

[Explain any issues that warrant further discussion. Considerations

-   What parts of the design do you expect to resolve through the NEP process before this gets merged?
-   What parts of the design do you expect to resolve through the implementation of this feature before stabilization?
-   What related issues do you consider out of scope for this NEP that could be addressed in the future independently of the solution that comes out of this NEP?]

## Changelog

[The changelog section provides historical context for how the NEP developed over time. Initial NEP submission should start with version 1.0.0, and all subsequent NEP extensions must follow [Semantic Versioning](https://semver.org/). Every version should have the benefits and concerns raised during the review. The author does not need to fill out this section for the initial draft. Instead, the assigned reviewers (Subject Matter Experts) should create the first version during the first technical review. After the final public call, the author should then finalize the last version of the decision context.]

### 1.0.0 - Initial Version

> Placeholder for the context about when and who approved this NEP version.

#### Benefits

> List of benefits filled by the Subject Matter Experts while reviewing this version:

-   Benefit 1
-   Benefit 2

#### Concerns

> Template for Subject Matter Experts review for this version:
> Status: New | Ongoing | Resolved

|   # | Concern | Resolution | Status |
| --: | :------ | :--------- | -----: |
|   1 |         |            |        |
|   2 |         |            |        |

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).
